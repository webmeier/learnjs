# Requesting many resources at once

You may find yourself requesting many resources in practice. How will you do this with XHR? How will you do this with Fetch? Is Fetch better than XHR if you need many resources?

Let's take a look at how you'll use these two techniques.

## The resources you're going to request for

We're going to keep it simple (and conceptual). Let's say you want to serve a meal. To serve this meal, you need to fetch three resources. All three resources must be ready before you can serve the meal.

The three resources are:

1. A burger
2. A pack of fries
3. A drink

(Note: substitute the three resources with three different Github requests if you want a real example üòâ).

## Fetching many resources with XHR

We learned that we need events to fetch resources with XHR. If we want all three resources, we can use three event listeners.

```js
const burgerRequest = new XMLHttpRequest()
const friesRequest = new XMLHttpRequest()
const drinkRequest = new XMLHttpRequest()

burgerRequest.addEventListener('load', e => { /* Burger's ready! */ })
burgerRequest.open('GET', 'Burger Link')
burgerRequest.send()

friesRequest.addEventListener('load', e => { /* Fries' ready! */ })
friesRequest.open('GET', 'Fries Link')
friesRequest.send()

drinkRequest.addEventListener('load', e => { /* Drink's ready! */ })
drinkRequest.open('GET', 'Drink Link')
drinkRequest.send()
```

The problem with the above approach is we don't know when all three resources are fetched. We only have information about one of them in each event listener.

One way to get all three resources is to wait for a response before sending the next request out. That means:

1. Send request for burger.
2. Wait for burger to be ready
3. Send request for fries
4. Wait for fries to be ready
5. Send request for drink
6. Wait for drink to be ready.

Here's what it might look like:

```js
burgerRequest.addEventListener('load', e => {
  // Burger is ready! Send request for fries now!
  const burger = e.target
  friesRequest.open('GET', 'Fries Link')
  friesRequest.send()
})

friesRequest.addEventListener('load', e => {
  // Fries is ready! Send request for drink now!
  const fries = e.target
  drinkRequest.open('GET', 'Drink Link')
  drinkRequest.send()
})

drinkRequest.addEventListener('load', e => {
  // Whoohoo! Everything is here. Serve meal!
  const drink = e.target
  serveMeal()
})

burgerRequest.open('GET', 'Burger Link')
burgerRequest.send()
```

You may be able to tell that the code above doesn't work. This is because `drinkRequest` doesn't have access to `burger` and `fries` due to scope issues.

For `drinkRequest` to have access to `burger` and `fries`, we need to nest event listeners, like this:

```js
burgerRequest.addEventListener('load', e => {
  // Burger is ready! Send request for fries now!
  const burger = e.target

  friesRequest.addEventListener('load', e => {
    // Fries is ready! Send request for drink now!
    const fries = e.target

    drinkRequest.addEventListener('load', e => {
      const drink = e.target
      serveMeal(burger, fries, drink)
    })

    drinkRequest.open('GET', 'Drink Link')
    drinkRequest.send()
  })

  friesRequest.open('GET', 'Fries Link')
  friesRequest.send()
})

burgerRequest.open('GET', 'Burger Link')
burgerRequest.send()
```

The code above works, but there are two problems.

First, it is confusing and complicated. We have callbacks nested in callbacks. This nested callback pattern is often called **callback hell**. We want to avoid nested callbacks because they make code harder to read.

Second, this method isn't the best approach. If we can fetch all three resources at the same time, why do limit ourselves to fetching one resource at a time? We don't want our users to wait unnecessarily.

The ideal solution to fetching many requests lies with promises.

## Promise.all

The `Promise` constructor has a method called `all`. `all` takes in an array of promises. It waits for all promises to resolve or reject before carrying out the next action.

The parameter in the `then` callback is an array. This array contains results from the promises. The order of the results is the same as the order of the promises.

```js
Promise.all([promise1, promise2, promise3])
  .then([result1, result2, result3] => {
    // Do something with each result
  })
```

Here's what our code might look like if we use promises to fetch `burger`, `fries` and `drink`. This assumes `getBurger`, `getFries`, and `getDrink` are promises.

```js
const burgerPromise = getBurger()
const friesPromise = getFries()
const drinkPromise = getDrink()

const serveMeal = Promise.all([
  burgerPromise,
  friesPromise,
  drinkPromise
])
  .then([burger, fries, drink] => {
    console.log(`${burger} üçî`)
    console.log(`${fries} üçü`)
    console.log(`${drink} üçπ`)
  })
```

## Fetching many resources with Fetch

The Fetch response object does not give you access to the data you want immediately. You need to use `response.json` to convert the data.

```js
fetch('link-to-github-repo')
  .then(response => response.json())
  .then(data => { /* do something with data*/ })
```

One thing to be aware of is that `response.json()` is another promise.

```js
fetch('link-to-github-repo')
  .then(response => {
    const promise = response.json()
    console.log(promise)
  })
```

<figure>
  <img src="../../images/ajax/promise/json-method-returns-promise.png" alt="The `json` method returns a promise">
  <figcaption aria-hidden>The `json` method returns a promise</figcaption>
</figure>

You have two ways to fetch burger, fries and drink with Fetch.

First, you run a Fetch with `Promise.all`. Then, you convert all fetch responses into JSON with another `Promise.all`.

```js
const burgerPromise = fetch('burger link')
const friesPromise = fetch('fries link')
const drinkPromise = fetch('drink link')

Promise.all([
  burgerPromise,
  friesPromise,
  drinkPromise
])
  .then(([burgerResponse, friesResponse, drinkResponse]) => {
    return Promise.all([
      burgerResponse.json(),
      friesResponse.json(),
      drinkResponse.json()
    ])
  })
  .then(([burger, fries, drink]) => {
    console.log(`${burger} üçî`)
    console.log(`${fries} üçü`)
    console.log(`${drink} üçπ`)
  })
```

The second solution is to run the first `then` call with each Fetch request. If you do this, you'll get the data immediately when you run `Promise.all`.

```js
const burgerPromise = fetch('burger link')
  .then(r => r.json())
const friesPromise = fetch('fries link')
  .then(r => r.json())
const drinkPromise = fetch('drink link')
  .then(r => r.json())

Promise.all([
  burgerPromise,
  friesPromise,
  drinkPromise
])
  .then(([burger, fries, drink]) => {
    console.log(`${burger} üçî`)
    console.log(`${fries} üçü`)
    console.log(`${drink} üçπ`)
  })
```

## XHR and Promises

You can convert event-driven XHR into promise-driven code too. This is quite complicated though. There are libraries that help you do that already. One example of such a library is Axios. You'll learn about Axios later.

## Exercise

Do this:

1. Request for three Github repositories with XHR
2. Request for three Github repositories with Fetch

