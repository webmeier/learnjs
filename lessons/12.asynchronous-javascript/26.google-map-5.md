# üõ†Ô∏è Google Maps Clone: Dealing with incomplete searches

There's one problem with Google's Autocomplete Widget. 

If a user types halfway and decides to click (or tab) away, the Autocomplete Widget leaves the user's original text in the input. It doesn't complete a value.  

<figure>
¬† <img src="/images/2018/" alt="">
¬† <figcaption></figcaption>
</figure>

When this happens, we won't be able to search for a direction from or to this incomplete text value. Google's Directions API can only search for directions if we provide a `formatted_address`, `Latlng` object, or a `Place` object. 

This text is simply a string. 

Let's handle this situation. 

## Detecting an incomplete search 

If the user selects an item from the Autocomplete dropdown, the Autocomplete Widget will return a valid `Place` when `getPlace` is called. 

The `Place` object is valid if it contains the properties we declared in Autocomplete Widget's `fields` options. 

```js
form.addEventListener('submit', evt => {
  // ... 
  const start = inputFields[0].autocompleteWidget.getPlace()
  console.log(`Starting Place: ${start}`)
})
```

<figure>
¬† <img src="/images/2018/" alt="">
¬† <figcaption></figcaption>
</figure>

When the place is not valid, Google's Autocomplete widget will return either of these two values: 

1. `undefined`
2. An object with the `name` property. The value of `name` is the value of the text input

<figure>
¬† <img src="/images/2018/" alt="">
¬† <figcaption></figcaption>
</figure>

<figure>
¬† <img src="/images/2018/" alt="">
¬† <figcaption></figcaption>
</figure>

Therefore, we need to check for two things to know if`getPlace` returns a valid `Place` object. They are: 

1. `Place` must not be undefined. It needs to be an object.
2. `Place` must contain `formatted_address` (or `Place` must not contain `name`). 

```js
if (typeof origin === 'object' && origin.formatted_address) {
  // Place is valid 
} else {
  // Place is invalid
}
```

We want to change the `start` value to a valid `Place` if it is not valid, so we flip the conditions. 

```js
if (typeof origin !== 'object' || !origin.formatted_address) {
  // Change start to a valid place
}  
```

## Getting a valid place 

You can use the the input's `value` to search for a valid place in many ways. One way to handle the situation is to fill up the search field with the first item in the Autocomplete Dropdown

One way to handle the situation is: We fill up the search field with the first item in the autocomplete dropdown. 

There are many ways to handle this situation of course. What we want is something that makes sense and doesn't break the UI. You may choose to handle it differently and that's perfectly fine! You do you! 


## Finding the first item 

If you look at the HTML, you will see two `.pac-containers`. These `.pac-containers` correspond to Autocomplete Widget. They are the dropdown for the Autocomplete Widgets. The first .pac-container links to the first search field, and so on. 

We know which `.pac-container` to use if we know the index of the field we're talking about. 

Two possible ways to detect... First is `undefined`. This happens when you type something and hit tab away. Second is it will contain a object with a `name` field. 

A proper `getPlace` will return a object with `formatted_address` and `geometry` like we defined. 

So we can check whether `start` is `undefined`. We also need to do a second check to make sure it is not an object and it doesn't contain `formatted_address` and `geometry`. Alternatively, we can check if it contains a `name` value. There are many ways of going about doing it. 

I like to be explicit, so I rather check for the presence of `formatted_address`. 

And then refactor the heck out of this!

The HTML looks like this: 

For example, if you followed along with the options mentioned so far, and you searched for North, the dropdown result will have the following HTML. 

<figure>
¬† <img src="/images/2018/" alt="">
¬† <figcaption></figcaption>
</figure>

```js
<div class="pac-container pac-logo">
  <div class="pac-item">
    <span class="pac-icon pac-icon-marker"></span>
    <span class="pac-item-query">
      <span class="pac-matched">North</span> Bridge Road</span
    >
    <span>Singapore</span>
  </div>
  <!-- ...other items -->
</div>
```

Here, you can see the first matched item is North Bridge Road. We need to convert the current format into `North bridge road, singapore`, as the value of the input, because that is the `formatted_address`. 

This will require some selector-fu plus `replace` to remove the `pac-matched` class. The code looks like this: 

Don't feel like explaining the selector-fu now... maybe better to do a textSearch? The alternative is to create an Autocomplete Service search... which is another hit to the Google APIs (which means some $$). 

```js
const dropdown = document.querySelectorAll('.pac-container')[0]
      const queryEl = dropdown.querySelector('.pac-item-query')
      const search = queryEl.innerHTML.replace('<span class="pac-matched">', '')
        .replace('</span>', '')
      const country = queryEl.nextElementSibling.textContent
      const address = `${search}, ${country}`
```
