# Building a calculator

This is the start of a three-part lesson about building a calculator. By the end of these three lessons, you should get a calculator that functions exactly like an iPhone calculator (without the `+/-` and percentage functionalities).

Here's what you'll get:

<figure>
  <img src="../../images/components/calculator/basic/calculator.gif" alt="GIF of a calculator you'll build">
  <figcaption aria-hidden>GIF of a calculator you'll build</figcaption>
</figure>

I urge you to sit down and try building the calculator yourself before following the lesson. It's a good practice.

A word of warningâ€”don't take the calculator lightly; it may seem simple at first, but you need to take care of many edge cases. When I tried to build the calculator, I had to redo it three times because I underestimated its complexity.

With that, let's begin by understanding how a calculator works.

## How a calculator works

What can possibly happen when a person gets hold of a calculator?

A few things can happen:

1. They hit a number key (0-9)
2. They hit an operator key (+, -, &times;, Ã·)
3. They hit the decimal key
4. They hit the equal key
5. They hit the clear key

Immediately, you have five branches of `if/else` statements. It can be overwhelming to consider everything at once, so let's take it step by step and consider what a normal person would do when they pick up a calculator.

## A normal flow

Let's call this normal person Mary.

When Mary picks up a calculator, she'll probably hit a number key.

### Hitting a number key

At this point, if the calculator shows 0 (the default number), the target number should replace zero.

<figure>
  <img src="../../images/components/calculator/basic/num-zero.gif" alt="Calculator replaces 0 with 9">
  <figcaption aria-hidden>Calculator replaces 0 with 9</figcaption>
</figure>

If the calculator shows a non-zero number, the target number should be appended to the displayed number.

<figure>
  <img src="../../images/components/calculator/basic/num-non-zero.gif" alt="Calculator appends 5 to 9">
  <figcaption aria-hidden>Calculator appends 5 to 9</figcaption>
</figure>

At this point, Mary will hit any of the following keys:

1. A decimal key
2. An operator key

Let's say Mary hits a decimal key.

### Hitting the decimal key

When Mary hits the decimal key, a decimal should appear on the display. If Mary hits any number after hitting a decimal key, the number should be appended on the display as well.

<figure>
  <img src="../../images/components/calculator/basic/decimal-non-zero.gif" alt="Calculator adds a decimal, followed by a number, to the display">
  <figcaption aria-hidden>Calculator adds a decimal, followed by a number, to the display</figcaption>
</figure>

Next, let's say Mary continues her calculation by hitting an operator key.

### Hitting an operator key

If Mary hits an operator key, the operator should be highlighted so Mary knows the operator is active.

<figure>
  <img src="../../images/components/calculator/basic/operator.gif" alt="Operator keys should be depressed when they're clicked on">
  <figcaption aria-hidden>Operator keys should be depressed when they're clicked on</figcaption>
</figure>

Once Mary has hit an operator key, if she is sensible, she'll hit a number key.

### Hitting a number key again

When Mary hits a number key again, the previous display should be replaced with the new number. The operator key should also release it's pressed state.

<figure>
  <img src="../../images/components/calculator/basic/num-after-operator.gif" alt="Display replaced by a new number">
  <figcaption aria-hidden>Display replaced by a new number</figcaption>
</figure>

Let's say Mary decides to complete her calculation by hitting the equal key next.

### Hitting the equal key

When Mary hits the equal key, the calculator should calculate a result, depending on the initial value entered before the operator, the operator, and the final value that's currently displayed.

Once a result is calculated, the result should replace the value on the display.

<figure>
  <img src="../../images/components/calculator/basic/equal.gif" alt="Calculates the correct value">
  <figcaption aria-hidden>Calculates the correct value</figcaption>
</figure>

## Let's take pause and build the above flow

First, we want to build the calculator.

The calculator consist of two parts. The display and the keys.

```html
<div class="calculator">
  <div class="calculator__display">0</div>
  <div class="calculator__keys"> ... </div>
</div>
```

We can use CSS Grid to make the keys since they're arranged in a grid-like format.

To help us identify operator, decimal, clear and equal keys, we're going to supply a data-action attribute that describes what they do.

```html
<div class="calculator__keys">
  <button class="key--modifier" data-action="add">+</button>
  <button class="key--modifier" data-action="subtract">-</button>
  <button class="key--modifier" data-action="multiply">&times;</button>
  <button class="key--modifier" data-action="divide">Ã·</button>
  <button>7</button>
  <button>8</button>
  <button>9</button>
  <button>4</button>
  <button>5</button>
  <button>6</button>
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>0</button>
  <button data-action="decimal">.</button>
  <button data-action="clear">AC</button>
  <button class="key--equal" data-action="calculate">=</button>
</div>
```

The above has already been done for you. You can find the calculator's starter code in `components/calculator/01.starter`.

## Listening for keys

Once we have the calculator, the next step is to listen for key presses. We want to use the event delegation pattern to listen to all keys at once.

Since we only want to perform actions when the keys are clicked on (we don't want to do anything when a user clicks on the lines), we want to check if the target is a `button` element.

```js
const calculator = document.querySelector('.calculator')
const keys = calculator.querySelector('.calculator__keys')

keys.addEventListener('click', e => {
  if (e.target.matches('button')) {
    // Do something
  }
})
```

We need to check the type of key the user has clicked on. To do so, you can use the `data-action` attribute.

```js
const key = e.target
const action = key.dataset.action
```

If the key does not have a `data-action`, attribute, the key is a number key.

```js
if (!action) {
  console.log('number key!')
}
```

If the key has a `data-action` attribute, we need to check what the attribute is. If it is either `add`, `subtract`, `multiply` or `divide`, the key is an operator key.

```js
if (
  action === 'add' ||
  action === 'subtract' ||
  action === 'multiply' ||
  action === 'divide'
) {
  console.log('operator key!')
}
```

If the `data-action` attribute is `decimal`, we know the user clicked on the decimal key. We can follow the same steps to detect the clear and equal keys.

```js
if (action === 'decimal') {
  console.log('decimal key!')
}

if (action === 'clear') {
  console.log('clear key!')
}

if (action === 'calculate') {
  console.log('equal key!')
}
```

At this point, when you click on any calculator key, you should get their relevant response.

<figure>
  <img src="../../images/components/calculator/basic/click-key.gif" alt="We're now able to detect different types of keys">
  <figcaption aria-hidden>We're now able to detect different types of keys</figcaption>
</figure>

## Implementing number keys

We know from above that, if a user clicks on the calculator when the calculator shows 0, the target number should replace zero.

We can get the clicked number through each key's `textContent` property. We can get the displayed number through the `textContent` property as well.

```js
const display = document.querySelector('.calculator__display')

keys.addEventListener('click', e => {
  if (e.target.matches('button')) {
    const key = e.target
    const action = key.dataset.action
    const keyContent = key.textContent
    const displayedNum = display.textContent

    if (!action) {
      if (displayedNum === '0') {
        display.textContent = keyContent
      }
    }

    // ...
  }
})
```

<figure>
  <img src="../../images/components/calculator/basic/num-zero.gif" alt="Replacing 0 with a number">
  <figcaption aria-hidden>Replacing 0 with a number</figcaption>
</figure>

If the calculator shows a non-zero number, the target number should be appended to the displayed number. To append a number, we concatenate a string.

```js
if (!action) {
  if (displayedNum === '0') {
    display.textContent = keyContent
  } else {
    display.textContent = displayedNum + keyContent
  }
}
```

<figure>
  <img src="../../images/components/calculator/basic/num-non-zero.gif" alt="Adding a number to another number on the display">
  <figcaption aria-hidden>Adding a number to another number on the display</figcaption>
</figure>

## Implementing the decimal key

If the user clicks on a decimal key, a decimal should be appended to the display. If they click on a number after clicking a decimal key, the number should be appended on the display as well.

```js
if (action === 'decimal') {
  display.textContent = displayedNum + '.'
}
```

<figure>
  <img src="../../images/components/calculator/basic/decimal-non-zero.gif" alt="Calculator adds a decimal, followed by a number, to the display">
  <figcaption aria-hidden>Calculator adds a decimal, followed by a number, to the display</figcaption>
</figure>


## Implementing the operator keys

If the user hits an operator key, the operator key should be highlighted so the user knows the operator is active. To highlight the operator key, we use the `is-depressed` class. (Oh no, this sounds so depressing!)

```js
if (
  action === 'add' ||
  action === 'subtract' ||
  action === 'multiply' ||
  action === 'divide'
) {
  key.classList.add('is-depressed')
}
```

<figure>
  <img src="../../images/components/calculator/basic/operator.gif" alt="Operator keys should be depressed when they're clicked on">
  <figcaption aria-hidden>Operator keys should be depressed when they're clicked on</figcaption>
</figure>


## When a user clicks a number after an operator key

When a user clicks another number after the operator key, the displayed number should update to reflect the new key. The operator key should also released it's pressed state.


To release the pressed state, we can loop through all keys and ensure that no key has the `is-depressed` class.

```js
keys.addEventListener('click', e => {
  if (e.target.matches('button')) {
    const key = e.target
    // ...

    Array.from(key.parentNode.children)
      .forEach(k => k.classList.remove('is-depressed'))
  }
})
```

To update the display with the new key, we need to know if the user clicked on an operator key previously. One way to detect the previous key is to save the type of the clicked key as a custom attribute.

```js
const calculator = document.querySelector('.calculator')
// ...

keys.addEventListener('click', e => {
  if (e.target.matches('button')) {
    // ...

    if (
      action === 'add' ||
      action === 'subtract' ||
      action === 'multiply' ||
      action === 'divide'
    ) {
      key.classList.add('is-depressed')
      calculator.dataset.previousKeyType = 'operator'
    }
  }
})
```

If the `previousKeyType` is an operator, we want to replace the displayed number with the new number.

```js
const previousKeyType = calculator.dataset.previousKeyType

if (!action) {
  if (displayedNum === '0' || previousKeyType === 'operator') {
    display.textContent = keyContent
  } else {
    display.textContent = displayedNum + keyContent
  }
}
```

<figure>
  <img src="../../images/components/calculator/basic/num-after-operator.gif" alt="">
  <figcaption aria-hidden></figcaption>
</figure>

## Implementing the calculate key

When a user clicks on a number, an operator, another number, and lastly, the equal key, we want to calculate and update the results.

<figure>
  <img src="../../images/components/calculator/basic/equal.gif" alt="Calculates the correct value">
  <figcaption aria-hidden>Calculates the correct value</figcaption>
</figure>

To do so, we need the previous `displayedNum` value (before we wiped it clean), the operator that was clicked on, and the current displayed value to perform a calculation. At this point, we're lacking the first two values.

To get the previous `displayedNum` value, we can create a custom attribute when the user clicks on an operator key.

To get the previously clicked `operator` value, we can create another custom attribute when the user clicks on an operator key.

```js
if (
  action === 'add' ||
  action === 'subtract' ||
  action === 'multiply' ||
  action === 'divide'
) {
  // ...
  calculator.dataset.firstValue = displayedNum
  calculator.dataset.operator = action
}
```

Once we have the three values we need, we can perform a calculation. Eventually, we want code to look something like this:

```js
if (action === 'calculate') {
  const firstValue = calculator.dataset.firstValue
  const operator = calculator.dataset.operator
  const secondValue = displayedNum

  display.textContent = calculate(firstValue, operator, secondValue)
}
```

Here, we know we need to create a `calculate` function. It should take in three valuesâ€”the first number, the operator, and the second number.

```js
const calculate = (n1, operator, n2) => {
  // Perform calculation and return value
}
```

If the operator is `add`, we want to add values together; if the operator is `subtract`, we want to subtract the values, and so on.

```js
const calculate = (n1, operator, n2) => {
  let result = ''

  if (operator === 'add') {
    result = n1 + n2
  } else if (operator === 'subtract') {
    result = n1 - n2
  } else if (operator === 'multiply') {
    result = n1 * n2
  } else if (operator === 'divide') {
    result = n1 / n2
  }

  return result
}
```

At this point, remember we're working with strings. If you add two strings together, you'll concatenate them, so `1 + 1` will be equal to 11.

But we don't want strings in the `calculate` function; we want numbers. JavaScript gives us two functions to convert strings into numbersâ€”`parseInt` and `parseFloat`.

- `parseInt` converts a string into an integer.
- `parseFloat` converts a string into a floating point number (this means a number with decimal places).

Since we need a floating point number, let's convert our numbers into floats prior to the calculation.

```js
const calculate = (n1, operator, n2) => {
  let result = ''

  if (operator === 'add') {
    result = parseFloat(n1) + parseFloat(n2)
  } else if (operator === 'subtract') {
    result = parseFloat(n1) - parseFloat(n2)
  } else if (operator === 'multiply') {
    result = parseFloat(n1) * parseFloat(n2)
  } else if (operator === 'divide') {
    result = parseFloat(n1) / parseFloat(n2)
  }

  return result
}
```

And we're done with the happy path.

## The happy path!

The happy path is a scenario where there are no errors or edge cases. When constructing the happy path above, we assumed that the user, like Mary, is a normal person who excels at using what we create.

Unfortunately, the unhappy path always occur in reality ðŸ˜¢. To prevent our app from crashing or exhibiting weird behaviors, we need to take care of all possible edge cases that may happen. You'll learn what these edge cases are and how to prevent them from happening in part 2.

## Wrapping up

We've built the ideal scenario where a user uses our calculator. It works, but we still need to take care of edge cases.

Before moving to the next lesson, I suggest you work through the happy path yourself. Make sure you get it to work without looking at the lesson.

I'll see you in the next lesson.