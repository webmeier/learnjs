# Function Composition

Function composition is the process where you **combine two smaller functions to make a larger function**.

Let's say you've already written two functions. One function, `add1` adds 1 to any number given to it. The second number, `times2`, multiplies a number by to.

```js
const add1 = num => num + 1
const times2 = num => num * 2
```

Let's say you now need a function that multiples a number by 2, then add 1 to it. One way to create this function is to redo the calculation, like this:

```js
const times2Add1 = num => num * 2 + 1
console.log(times2Add1(5)) // 11
```

Another way to create this `times2Add1` function is to combine your smaller `add1` and `times2` functions. This second method is done through function composition.

```js
const times2Add1 = num => add1(times2(num))
console.log(times2Add1(5)) // 11
```

(Note: Can you understand why add1(Times2(num)) works? If you don't, go back to the [functions](../02.js-basics/07.functions.md) chapter and work through the flow of a function again).

## Yuck! Who would compose functions?!

You're right. `add1(times2(num))` is pretty nasty to read. Anyone would rather write `num * 2 + 1` than `add1(times2(num))` any day.

So, why would you compose functions?

First, remember we're dealing with very easy functions in this example. Real world functions are generally more complex than adding and multiplying numbers.

Second, functional programming experts have a way to make functions easier to read. They make use of another function called `pipe` that helps you combine two or more functions without the ugly syntax.

A simple implementation of `pipe` that combines two functions may look like this:

```js
function pipe (fn1, fn2) {
  return function (num) {
    return fn2(fn1(num))
  }
}
```

Hoo boy, the `pipe` function looks complicated. If you realized, a [closure](../02.js-basics/09.scopes-and-closures.md) has came into play. (Remember, when you create an inner function in an outer function, the inner function is the closure).

Let's create the `times2Add` function with `pipe` and see if it works first.

```js
const times2Add1 = pipe(times2, add1)
const results = times2Add1(5)
console.log(results)
```

Okay, it works. Let's understand what's happening, step by step.

## Explaining pipe

First, you create a new function with `pipe(times2, add1)` When you do so, JavaScript needs to evaluate what is `pipe(times2, add1)` first before it can assign it to your `times2Add1` variable.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Here, it sees that there is a `pipe` function, so it adds `times2` and `add1` as the parameters to the pipe function.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

In the `pipe` function, times2 is assigned to `fn1` and `add1` is assigned to fn2.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Once the assignment is complete, JavaScript sees the return statement, so it returns `function (num) {return fn2(fn1(num))}` and moves into the next line.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Here, JavaScript sees you called `times2Add1` with `5` as the argument. So, `5` is assigned as `num`

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

In the `times2Add1` function, it sees it needs to return `fn2(fn1(5))`.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Because `times2Add1` is a closure, and `fn1` is already assigned as `times2`, and `fn2` is already assigned as `add1`, it replaces the functions accordingly.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Then, JavaScript evaluates the inner function, `times2(5)`, followed by the outer function `add1(10)`

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Then, it returns the value as results.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

And that, is a nutshell of how `pipe` (and other closures) work.

## Back to composition

Now, if you compare the `pipe` version of `times2Add1` with the manual version of `times2Add1`, which is easier to read?

```js
const manualVersion = num => n * 2 + 1
const pipeVersion = pipe(times2, add1)
```

If you like Math, you'll probably say the first one. If you hate math, you'll say the second one.

Now, the two-function pipe is a simple example. What happens in practice, is that functional programming experts combine 3, 4 or even more functions together. The actual pipe implementation looks like this:

```js
const pipe = (...fns) =>
  arg =>
    fns.reduce((acc, fn) => fn(acc), arg)
```

Now, compare these two versions, again, which one is easier to read?

```js
const manualVersion = num => (num * 2 + 1) * 2 + 1
const pipeVersion = pipe(times2, plus1, times2, plus1)

console.log(manualVersion(5)) // 23
console.log(pipeVersion(5)) // 23
```

In the `pipe` version, `times2Add1` is much easier to understand, right? That's why

If you `console.log(times2Add1)`, you'll see that `times2Add1` is a function. This is to be expected since the `pipe` function returns another function.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

I'm trying to draw a line on saying: Where should you stop learning Functional Programming andou carry on with actually programming things from the real world?

My answer, really, is to build things first. Then, slowly refactor them to become more functional as you build more things.

It's hard to see why you'll use functional programming when you're starting out. It feels lame. So, in take this lesson with a pinch of salt and try to understand on a very basic level what Functional Programming is about.

If you want to find out more, I suggest you read X or you wait and I'll create a better book on Functional Programming at a later date. ðŸ˜„

Okay anyway, so let's talk about function composition. Yes.

Let's take a super simple example.

Say you want to create a function that adds 10 to a number, then multiplies it by 5. (I know nobody would write such a function, but bear with me because its easier to explain the concepts with these numbers. You'll learn real application when you build components up).

One way to create this function is to create the function directly.

```js
const add10Times5 = num => (num + 10) * 5
```

Now, let's say you want to create another function that multiples your current number by 5 first, then add 10 to it after the multiplication.

```js
const times5Add10 = num => num * 5 + 10
```

Now, both functions are similar, they use the same things

1. Adding a number by 10
2. Multiplying a number by 5

So, if you were to refactor both codes, you could create a function that purely adds a number by ten, and other that adds multiplies a number by 5:

```js
const times5 = num => num * 5
const add10 = num => num + 10
```

Now, if you wish to create a function that first multiplies by 5, then add ten, you can do call `times5` and `add10`.

```js
const times5Add10 = num => add10(times5(num))
```

This is starting to sound stupid. Lol. And I should probably write a number here to show that the ansewr is right. And also to explain why it's like this. Inner first, then outer.

Now, if you want to reverse the order, meaning you want to times 2 then add 1, you can do so too, by creating a new function:

```js
const times2Add1 = num => times2(add1(num))
```

This is function composition. How can anyone read this! It looks like shit!

Enter compose and pipe.

## Compose and Pipe.

Functional composition looks like ðŸ’© in JavaScript. Try reading it, you'll probably get confused. This is why Functional Composition experts created two functions to help you with function composition â€“ compose and pipe.

They look like this. (Note: you don't have to understand why they work at this point. Instead, understand how they work, so you can use it when the need arises. You can dig into the code at a later time, it's not important now, I don't even want to mention compose and pipe, but I kind of have to.

```
const compose =
const pipe =
```

Maybe I should just say pipe. It means the same thing

const add1Times2 = pipe(add1, times2).

And that's all you need to know about Functional Composition for now. You can try taking it further and writing expertly crafted functional stuff, but its going to be quite harsh on the brain right now. What you're interested in is to learn to build real components, so let's hurry along to built real components and return to functional programming when you've built lots of stuff and you want to improve them.

(Maybe in another book. I want to emphasize this part, because I won't be explaining them here). Maybe I should say I'm not well versed in FP myself too. But I can't really say it when I have a book to write. Can I?

I can say from experience, you don't erally need functional programming to build simple things, so we won't really be using functional programming in this course. You'll however, get to see a glimpse of it being used, and I'll show you how and where.

Let's move on into the more practical parts for Functional Programming â€“ Functional array methods.