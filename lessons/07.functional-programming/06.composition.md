# Function Composition

Let's say you have two simple pure functions â€“ `add1` and `times2`. `add1` adds 1 to any number given to it, and `times2`, multiples a number by 2.

```js
const add1 = num => num + 1
const times2 = num => num * 2
```

Let's further say you need a function, `times2Add1`, that multiplies a number by 2, then add 1 to it. One way to create this function is to perform the calculation with Math and Algebra, like this:

```js
const times2Add1 = num => num * 2 + 1
console.log(times2Add1(5)) // 11
```

Another way to create `times2Add1` is to combine your `add1` and `times2` function. This second method is function composition.

**Function composition is the process where you combine two smaller functions to make a larger function**.

```js
const times2Add1 = num => add1(times2(num))
console.log(times2Add1(5)) // 11
```

Can you understand why add1(Times2(num)) works? Take your time and work through how the function flows. It's important that you understand how functions can be combined.

If you need to, you might want to go back to the [functions](../02.js-basics/07.functions.md) chapter and work through example again.

## Yuck! Who would compose functions?!

You're right. `add1(times2(num))` is pretty nasty to read. I would rather write `num * 2 + 1` than `add1(times2(num))` any day.

So, why would you compose functions?

First, remember we're dealing with very easy functions in this example. Real world functions are generally more complex than adding and multiplying numbers.

Second, functional programming experts have a way to make functions easier to read. They make use of a function called `pipe` that helps you combine two or more functions without the ugly syntax.

A simple implementation of `pipe` that combines two functions may look like this:

```js
function pipe (fn1, fn2) {
  return function (num) {
    return fn2(fn1(num))
  }
}
```

Hoo boy, the `pipe` function looks complicated! If you realized, `pipe` contains a [closure](../02.js-basics/09.scopes-and-closures.md) has came into play. (Remember, when you create an inner function in an outer function, the inner function is the closure).

It's important to understand how `pipe` works if you want to have a glimpse of how expert-level programmers write their code. So, let's create the `times2Add1` function with `pipe` and see how it works.

```js
const times2Add1 = pipe(times2, add1)
const results = times2Add1(5)
console.log(results) // 11
```

## Explaining pipe

First, you create `times2Add1` by writing `pipe(times2, add1`). Here, JavaScript needs to evaluate what `pipe(times2, add1)` is before it can assign it to `times2Add1`.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

While trying to figure out `pipe(times2, add1)`, JavaScript sees that `pipe` is a function and `times2` and `add1` are parameters. So, it passes them into the `pipe` function.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

In the `pipe` function, times2 is assigned to `fn1` and `add1` is assigned to fn2.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Once the assignment is complete, JavaScript sees a return statement. This return statement says to return `function (num) {return fn2(fn1(num))}`.

Since a function is a valid value, JavaScript returns the function to `times2Add1`. This is how `times2Add1` becomes a function.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

In the next line, you call the `times2Add1` function. This time, JavaScript sees that `times2Add` is a function, and it needs to pass in number, 5, as the argument.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

After assigning `5` to num, JavaScript needs to return `fn2(fn1(5))`. `fn2(fn1(5))` is an expression, so JavaScript needs to evaluate first.

Here, `times2` is already assigned to `fn1`, and `add1` is assigned to `fn2`. So, JavaScript replaces `fn1` and `fn2` with `times2` and `add1` respectively.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Then, JavaScript evaluates the inner function, `times2(5)`, followed by the outer function `add1(10)`

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

Then, it returns the value as results.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

And that, is a nutshell of how `pipe` (and other closures) work.

## Back to composition

Now, if you compare the `pipe` version of `times2Add1` with the manual version of `times2Add1`, which is easier to read?

```js
const manualVersion = num => n * 2 + 1
const pipeVersion = pipe(times2, add1)
```

If you like Math, you'll probably say the first one. If you hate math, you'll say the second one.

Now, the two-function pipe is a simple example. What happens in practice, is that functional programming experts combine 3, 4 or even more functions together. The actual pipe implementation looks like this:

```js
const pipe = (...fns) =>
  arg =>
    fns.reduce((acc, fn) => fn(acc), arg)
```

Now, compare these two versions, again, which one is easier to read?

```js
const manualVersion = num => (num * 2 + 1) * 2 + 1
const pipeVersion = pipe(times2, plus1, times2, plus1)

console.log(manualVersion(5)) // 23
console.log(pipeVersion(5)) // 23
```

In the `pipe` version, `times2Add1` is much easier to understand, right? That's why

If you `console.log(times2Add1)`, you'll see that `times2Add1` is a function. This is to be expected since the `pipe` function returns another function.

<figure>
  <img src="/images/2017/" alt="">
  <figcaption></figcaption>
</figure>

I'm trying to draw a line on saying: Where should you stop learning Functional Programming andou carry on with actually programming things from the real world?

My answer, really, is to build things first. Then, slowly refactor them to become more functional as you build more things.

It's hard to see why you'll use functional programming when you're starting out. It feels lame. So, in take this lesson with a pinch of salt and try to understand on a very basic level what Functional Programming is about.

If you want to find out more, I suggest you read X or you wait and I'll create a better book on Functional Programming at a later date. ðŸ˜„

Okay anyway, so let's talk about function composition. Yes.

Let's take a super simple example.

Say you want to create a function that adds 10 to a number, then multiplies it by 5. (I know nobody would write such a function, but bear with me because its easier to explain the concepts with these numbers. You'll learn real application when you build components up).

One way to create this function is to create the function directly.

```js
const add10Times5 = num => (num + 10) * 5
```

Now, let's say you want to create another function that multiples your current number by 5 first, then add 10 to it after the multiplication.

```js
const times5Add10 = num => num * 5 + 10
```

Now, both functions are similar, they use the same things

1. Adding a number by 10
2. Multiplying a number by 5

So, if you were to refactor both codes, you could create a function that purely adds a number by ten, and other that adds multiplies a number by 5:

```js
const times5 = num => num * 5
const add10 = num => num + 10
```

Now, if you wish to create a function that first multiplies by 5, then add ten, you can do call `times5` and `add10`.

```js
const times5Add10 = num => add10(times5(num))
```

This is starting to sound stupid. Lol. And I should probably write a number here to show that the ansewr is right. And also to explain why it's like this. Inner first, then outer.

Now, if you want to reverse the order, meaning you want to times 2 then add 1, you can do so too, by creating a new function:

```js
const times2Add1 = num => times2(add1(num))
```

This is function composition. How can anyone read this! It looks like shit!

Enter compose and pipe.

## Compose and Pipe.

Functional composition looks like ðŸ’© in JavaScript. Try reading it, you'll probably get confused. This is why Functional Composition experts created two functions to help you with function composition â€“ compose and pipe.

They look like this. (Note: you don't have to understand why they work at this point. Instead, understand how they work, so you can use it when the need arises. You can dig into the code at a later time, it's not important now, I don't even want to mention compose and pipe, but I kind of have to.

```
const compose =
const pipe =
```

Maybe I should just say pipe. It means the same thing

const add1Times2 = pipe(add1, times2).

And that's all you need to know about Functional Composition for now. You can try taking it further and writing expertly crafted functional stuff, but its going to be quite harsh on the brain right now. What you're interested in is to learn to build real components, so let's hurry along to built real components and return to functional programming when you've built lots of stuff and you want to improve them.

(Maybe in another book. I want to emphasize this part, because I won't be explaining them here). Maybe I should say I'm not well versed in FP myself too. But I can't really say it when I have a book to write. Can I?

I can say from experience, you don't erally need functional programming to build simple things, so we won't really be using functional programming in this course. You'll however, get to see a glimpse of it being used, and I'll show you how and where.

Let's move on into the more practical parts for Functional Programming â€“ Functional array methods.