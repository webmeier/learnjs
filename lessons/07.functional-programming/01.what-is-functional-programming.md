# What is Functional Programming?

You're now past the beginner stage for Javascript. From now on, the things you make will be a lot more complicated than simply adding event listeners.

So, before you dive into creating more components, it makes sense to take a step back and learn how to improve your code.

When you search around for programming practices, you'll come across two main styles – Functional Programming and Object Oriented Programming.

There's a lot of noise and biased opinions about both Functional and Object Oriented Programming out there on the internet. Some articles say Functional Programming is better than Object Oriented Programming. Others say Object Oriented Programming is superior.

But **it's a mistake to compare Object Oriented Programming with Functional Programming directly. If you do compare them, you're trying to compare apples and oranges.**

So stop comparing the two programming styles.

In reality, Functional Programming and Object Oriented Programming can be used together. If you want to use them together, you will need to understand each programming paradigm first.

In this module, you'll learn about Functional Programming.

## Functional Programming is about Composition

In Functional Programming, you want to combine smaller functions to make a bigger function. This is a process called **composition**.

Before composition can occur, you need to **write functions that return the same value when the same inputs are given to it.**

In other words, if you add `1 + 2 + 3`, you must always get back a value of 6. You will never get 12 or 17.

An example of a function that follows the Functional Programming paradigm (or style) is `addTen`.

```js
const addTen = num => num + 10
```

It doesn't matter how many times you run `addTen`. If you pass in 25 as your parameter to `addTen`, `addTen` will always give you back 35.

```js
console.log(addTen(25)) // 35
console.log(addTen(25)) // 35
console.log(addTen(25)) // 35
console.log(addTen(25)) // 35
```

Now, contrast this with another function called `addAnotherTen`. `addAnotherTen` is written this way:

```js
let num = 25
const addAnotherTen = _ => {
  num = num + 10
}
```

The result from `addAnotherTen` changes depending on the value of `num`.

When you run `addAnotherTen` for the first time, you'll get back 35. If you run `addAnotherTen` again, you'll get back 45. If you run `addAnotherTen` again, you'll get 55.

```js
addAnotherTen() // num === 35
addAnotherTen() // num === 45
addAnotherTen() // num === 55
addAnotherTen() // num === 65
```

**The key in Functional Programming is to write functions that doesn't change the state of the program**, like `addTen`.

## State

The English dictionary defines state as a condition that someone or something is in at a specific time.

In programming, you can understand **state** as the **condition of the program at a specific time**. If the program remembers its current condition, it is said to be **stateful**. If it doesn't remember its current condition, it is said to be **stateless**.

Let's dive into examples to make things clearer.

Let's say you created a variable called `myName`. Once you've created the variable, you can use it anywhere. JavaScript remembers it.

```js
const myName = 'Zell'
console.log(myName) // Zell
```

In this case, the program you've written is said to be stateful. It remembers you have a variable called `myName`, and it remembers that `myName` has the value `Zell`.

**So, the moment you start using variables, your program is stateful.**

It doesn't make sense to talk about stateful or stateless programs since every program requires variables; they're always stateful. What's more interesting is to dive deeper into the program and consider if your functions are stateful.

### Stateful functions

**A stateful function is a function that remembers or changes state.** An example of such a function is `addAnotherTen`.

```js
// addAnotherTen is stateful
let num = 25
const addAnotherTen = _ => {
  num = num + 10
}
```

When `addAnotherTen` runs, JavaScript goes to look for the value of `num`. It finds and changes the current `num` value, within the function. Then, it forces the program to remember the new `num` value.

### Stateless functions

**A stateless function is a function that doesn't remember state** (even though state may be present). `addTen` is an example of such a function.

```js
const origNum = 22
const addTen = num => {
  console.log(num) // 22
  return num + 10
}

console.log(addTen(origNum)) // 32
```

When `addTen(origNum)` runs, the program assigns the variable `num` with a value of 22. Here, the program is stateful, because it remembers that `num` is 22.

Next, the program adds 10 to `num` and returns the new value, 32. Here, state is present. `num` is still 22.

When the program exits `addTen`, `num` gets destroyed. At this point, `addTen` forgets the value of `num`, and you can no longer retrieve `num` anywhere. Here, you can see that `addTen` doesn't care about its internal state.

In addition, `addTen` doesn't change the external state (the state outside of itself) as well. If you console.log `origNum`, you'll see that `origNum` remains at its original value, 22.

```js
console.log(origNum) // 22
```

Because `addTen` doesn't remember its internal state, and it doesn't change the external state, `addTen` is considered to be stateless.

Stateless functions are also called **pure functions**. Pure functions do not introduce side effects.

## Side effects

When a function **modifies the external state**, it is said to introduce **side effects**. Side effects sound bad; they sound like the aftereffects of a drug gone terribly wrong.

But don't worry, side effects aren't serious live-and-death problems. They happen naturally. In fact, they need to happen for your program to work, and you have written a few side effects already.

When you change the class of a HTML Element, you introduce a side effect. The state has changed.

When you change an attribute of a HTML Element, you also introduce a side effect.

When you add or remove an element from the DOM, you also introduce a side effect.

Side effects cannot be completely avoided, or your program would do nothing.

### Side effects can be hard to track

In functional programming, you want to reduce side effects as much as possible because the changes introduced by side effects become hard to track as the size of your program increases.

The most dangerous type of side effects are those that change without you knowing they changed.

To find out what can cause such a change, you have to understand mutability.

## Mutability

Mutability comes from the word mutate. **To mutate means to change in form or nature**. Something that’s mutable can be changed, while something that’s immutable cannot be changed.

**To understand mutation, think of the X-Men.**.

In X-Men, people can suddenly gain powers. The problem is, you don’t know when these powers will emerge. Imagine your friend turns blue and grows fur all of a sudden; that’d be scary, wouldn’t it?.

### Objects are mutable

In JavaScript, objects (including functions and arrays) are mutable. When you change a property of an object, the object is changed permanently. It mutates, like how an X-Men member mutates when they gain powers.

In the example below, the variable `egg` mutates once you add the isBroken property to it. We say that objects (like `egg`) are mutable (have the ability to mutate).

```js
const egg = {name: 'Humpty Dumpty'}
egg.isBroken = false

console.log(egg)
// {
//   name: 'Humpty Dumpty',
//   isBroken: false
// }
```

Mutation is pretty normal in JavaScript. You use it all the time.

### Here’s when mutation becomes scary.

Let’s say you create a constant variable called `newEgg` and assign `egg` to it. Then you want to change the name of `newEgg` to something else.

Let's say you create a variable called `newEgg` and assign `egg` to it. Then, you decide to change the properties of the original `egg`.

```js
const egg = { name: "Humpty Dumpty" }

const newEgg = egg
newEgg.name = "Errr ... Not Humpty Dumpty"
```

When you change (mutate) newEgg, did you know egg gets mutated automatically?

```js
console.log(egg)
// {
//   name: "Errr ... Not Humpty Dumpty"
// }
```

**The example above illustrates why mutation can be scary—when you change one piece of your code, another piece can change somewhere else without your knowing. As a result, you’ll get bugs that are hard to track and fix.**

This weird behavior happens because objects are passed by reference in JavaScript.

### Objects are passed by references

To understand what “passed by reference” means, first you have to understand that each object has a unique identity in JavaScript. When you assign an object to a variable, you link the variable to the identity of the object (that is, you pass it by reference) rather than assigning the variable the object’s value directly. This is why when you compare two different objects, you get false even if the objects have the same value.

```js
console.log({} === {}) // false
```

When you assign `egg` to `newEgg`, `newEgg` points to the same object as `egg`. Since `egg` and `newEgg` are the same thing, when you change `newEgg`, `egg` gets changed automatically.

```js
console.log(egg === newEgg) // true
```

Unfortunately, you don’t want `egg` to change along with `newEgg` most of the time, since it causes your code to break when you least expect it. So how do you prevent objects from mutating? You'll learn how to in a future lesson.

But before you understand how to prevent objects from mutating, you need to know what’s immutable in JavaScript.

## Primitives are immutable in JavaScript

In JavaScript, primitives (String, Number, Boolean, Null, Undefined, and Symbol) are immutable; you cannot change the structure (add properties or methods) of a primitive. Nothing will happen even if you try to add properties to a primitive.

```js
const egg = "Humpty Dumpty"
egg.isBroken = false

console.log(egg) // Humpty Dumpty
console.log(egg.isBroken) // undefined
```

## Const doesn't grant immutability

Many people think that variables declared with `const` are immutable. That’s an incorrect assumption.

Declaring a variable with `const` doesn’t make it immutable, it prevents you from assigning another value to it.

```js
const myName = "Zell"
myName = "Triceratops"
// ERROR
```

When you declare an object with `const`, you’re still allowed to mutate the object. In the `egg` example, even though `egg` is created with `const`, `const` doesn’t prevent `egg` from mutating.

```js
const egg = { name: "Humpty Dumpty" }
egg.isBroken = false

console.log(egg)
// {
//   name: "Humpty Dumpty",
//   isBroken: false
// }
```

## Don't confuse reassignment with mutation

When you reassign a variable, you change what it points to. In the following example, `a` is changed from `11` to `100`.

```js
let a = 11
a = 100
```

When you mutate an object, it gets changed. The reference to the object stays the same.

```js
const egg = {name: 'Humpty Dumpty'}
egg.isBroken = false
```

Mutation is not the same as reassignment. Don't confuse the two of them.

## Wrapping up

Don't compare Functional Programming and Object Oriented programming. If you do, you're comparing apples and oranges.

In Functional Programming, you want to combine smaller functions into bigger functions. This process is known as composition.

Before composition can occur, you need to write pure (or stateless) functions that do not introduce side effects. These functions should not change the state of the program via reassignment or mutation.