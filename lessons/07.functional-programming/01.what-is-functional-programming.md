# What is Functional Programming?

Functional programming is a style of programming. Traditionally it is used for academic purposes. In recent years, more people have found Functional Programming useful for their applications and have adopted it as their programming style.

If you search for Functional Programming, you will also come across Object Oriented Programming (another programming style) as well.

Some articles you've read would say Functional Programming is better than Object Oriented Programming. Some others would say Object Oriented Programming is superior.

Both types of articles have gotten it wrong. **It's a mistake to compare Object Oriented Programming with Functional Programming. If you do compare them, you're trying to compare apples and oranges.**

So stop comparing the two programming styles.

In reality, Functional Programming and Object Oriented Programming can be used together. If you want to use them together, you will need to understand each programming paradigm first.

Let's dive into Functional Programming first.

## What is Functional Programming?

In Functional Programming, you want to combine smaller functions to make a bigger function. This is a process called **composition**.

Before composition can occur, you need to **write functions that return the same value when the same inputs are given to it**

In other words, if you add `1 + 2 + 3`, you must always get back a value of 6. You will never get 12 or 17.

An example of a function that follows the Functional Programming paradigm (or style) is `addTen`.

```js
const addTen = num => num + 10
```

It doesn't matter how many times you run `addTen`. If you pass in 25 as your parameter to `addTen`, `addTen` will always give you back 35.

```js
console.log(addTen(25)) // 35
console.log(addTen(25)) // 35
console.log(addTen(25)) // 35
console.log(addTen(25)) // 35
```

Now, contrast this with another function called `addAnotherTen`. `addAnotherTen` is written this way:

```js
let num = 25
const addAnotherTen = _ => {
  num = num + 10
}
```

The result from `addAnotherTen` changes depending on the value of `num`.

When you run `addAnotherTen` for the first time, you'll get back 35. If you run `addAnotherTen` again, you'll get back 45. If you run `addAnotherTen` again, you'll get 55.

```js
addAnotherTen() // num === 35
addAnotherTen() // num === 45
addAnotherTen() // num === 55
addAnotherTen() // num === 65
```

**The key in Functional Programming is to write functions that doesn't change the state of the program**, like `addTen`.

## State

The English dictionary defines state as a condition that someone or something is in at a specific time.

In programming, you can understand **state** as the **condition of the program at a specific time**. If the program remembers its current condition, it is said to be **stateful**. If it doesn't remember its current condition, it is said to be **stateless**.

Let's dive into examples to make things clearer.

Let's say you created a variable called `myName`. Once you've created the variable, you can use it anywhere. JavaScript remembers it.

```js
const myName = 'Zell'
console.log(myName) // Zell
```

In this case, the program you've written is said to be stateful. It remembers you have a variable called `myName`, and it remembers that `myName` has the value `Zell`.

**So, the moment you start using variables, your program is stateful.**

Now, it doesn't make sense to talk about stateful or stateless programs since every program requires variables â€“ they're always stateful.

What's more interesting is to dive deeper into the program and consider if your functions are stateful.

### Stateful functions

**A stateful function is a function that remembers or changes state.** An example of such a function is `addAnotherTen`.

```js
// addAnotherTen is stateful
let num = 25
const addAnotherTen = _ => {
  num = num + 10
}
```

When `addAnotherTen` runs, JavaScript goes to look for the value of `num`. It finds and changes the current `num` value, within the function. Then, it forces the program to remember the new `num` value.

### Stateless functions

**A stateless function is a function that doesn't remember state** (even though state may be present). `addTen` is an example of such a function.

```js
const origNum = 22
const addTen = num => {
  console.log(num) // 22
  return num + 10
}

console.log(addTen(origNum)) // 32
```

When `addTen(origNum)` runs, the program assigns the variable `num` with a value of 22. Here, the program is stateful, because it remembers that `num` is 22.

Next, the program adds 10 to `num` and returns the new value, 32. Here, state is present. `num` is still 22.

When the program exits `addTen`, `num` gets destroyed. At this point, `addTen` forgets the value of `num`, and you can no longer retrieve `num` anywhere. Here, you can see that `addTen` doesn't care about its internal state.

In addition, `addTen` doesn't change the external state (the state outside of itself) as well. If you console.log `origNum`, you'll see that `origNum` remains at its original value, 22.

```js
console.log(origNum) // 22
```

Because `addTen` doesn't remember its internal state, and it doesn't change the external state, `addTen` is considered to be stateless.

Stateless functions are also called **pure functions**. Pure functions do not introduce side effects.

## Side effects

When a function **modifies the external state**, it is said to introduce **side effects**. Now, side effects sound bad. They sound like the aftereffects of a drug gone terribly wrong and you may die any minute.

But don't worry, side effects aren't serious live-and-death problems. They happen naturally. In fact, they need to happen for your program to work, and you have written a few side effects already.

When you change the class of a HTML Element, you introduce a side effect. The state has changed.

When you change an attribute of a HTML Element, you also introduce a side effect.

When you add or remove an element from the DOM, you also introduce a side effect.

Side effects cannot be completely avoided, or your program would do nothing.

### Side effects can be hard to track

In functional programming, you want to reduce side effects as much as possible because the changes introduced by side effects become hard to track as the size of your program increases.

The most dangerous type of side effects are those that change without you knowing they changed.

To find out what can cause such a change, you have to understand mutability.

## Mutability

Mutability comes from the word mutate. **To mutate means to change in form or nature**. A mutable thing can be changed while an immutable thing cannot be changed.

**To envision mutability, think about X-men**.

In X-men, the genetic makeup of some humans have changed so much that they are able to control new powers. Since all humans are born without power, but they acquired them because their genes have changed, humans in X-men can be considered mutable.

(That's why X-men are called mutants ðŸ˜‰).

**To envision immutability, think about a cup**. It cannot change to something else. It is immutable.

### Primitives are immutable

Primitives (`Strings`, `Numbers`,` Booleans`, `Null`, `Undefined` and `Symbol`) are immutable in JavaScript. This means you cannot change the structure of a primitive (you cannot add methods or properties to a primitive).

Let's say you try to add a property to a String. To do so, you create a variable called `egg` and give it the string `Humpty Dumpty`.

Then, you try to set the `isBroken` property on `egg`. But, no matter what you do, this property will not get changed.

```js
const egg = 'Humpty Dumpty'
egg.isBroken = false

console.log(egg) // Humpty Dumpty
console.log(egg.isBroken) // undefined
```

But the same behavior doesn't happen with objects.

### Objects are mutable

In JavaScript, objects (including functions and arrays) are mutable. When you change the property of a variable, the change remains.

```js
const egg = {name: 'Humpty Dumpty'}
egg.isBroken = false

console.log(egg)
// {
//   name: 'Humpty Dumpty',
//   isBroken: false
// }
```

### Mutable objects can be scary

Let's say you create a variable called `newEgg` and assign `egg` to it. Then, you decide to change the properties of the original `egg`.

```js
const egg = {name: 'Humpty Dumpty', isBroken: false}
const newEgg = egg

egg.isBroken = true
```

When you change `egg`, did you know `newEgg` also gets changed at the same time?

**This is why mutable objects are scary â€“ you can accidentally change something, and somewhere else, your program gets broken**.

Often, when your program breaks because something has mutated, you'll no idea where the mutation happened, how it happened, and why it happened.

```js
console.log(newEgg)
// {
//   name: 'Humpty Dumpty',
//   isBroken: true
// }
```

But why does `newEgg` change when you all you do was to change `egg`?

### Objects are passed by references in JavaScript

To understand why, you first have to understand than each object has an unique identity. So, even if two objects have the same value, they are not the same object.

```js
console.log({} === {}) // false
```

When objects are created, they hold on to their unique identities. When you assign an object to the variable, you assign the reference to this unique object to the variable, not the value of the object itself.

This is why whet you assign `egg` to `newEgg`, `newEgg` points to the same object as `egg`.

So you've seen how mutation can be scary with Objects. The question is, how do you prevent objects (and arrays, since arrays are objects) from mutating? You'll find some answers in the following lessons to come.

## Don't confuse reassignment with mutation

When you reassign variables, you change what a variable points to. In the following example, `a` is changed from 11 to 100.

```js
let a = 11
a = 100
```

When you mutate, the object gets changed. The reference to the object stays the same.

```js
const egg = {name: 'Humpty Dumpty'}
egg.isBroken = false
```

### Const doesn't grant immutability

Many people think that variables declared with `const` are immutable. That's a wrong assumption.

`const` is not immutable. It only prevents you from assigning another value to a variable declared with `const`.

In the `egg` example above, even though `egg` is created with `const`, `const` doesn't prevent `egg` from mutating.

```js
const egg = {name: 'Humpty Dumpty'}
egg.isBroken = false

console.log(egg)
// {
//   name: 'Humpty Dumpty',
//   isBroken: false
// }
```

## Wrapping up

Don't compare Functional Programming and Object Oriented programming. If you do, you're comparing apples and oranges.

In Functional Programming, you want to combine smaller functions into bigger functions. This process is known as composition.

Before composition can occur, you need to write pure (or stateless) functions that do not introduce side effects. These functions should not change the state of the program via reassignment or mutation.