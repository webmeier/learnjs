# Reduce control flows

<!-- Change to avoid reassignments instead -->

Control flows are branches that tell code how to behave given a certain condition. `if/else` statements and `for` loops are examples of control flows.

Let's say you're shopping for a toy. This toy is for your friend's newborn baby. You think to yourself, if the newborn is a girl, you want to gift her a doll. If the newborn is a boy, you want to gift her a car.

Here's what you may write:

```js
let toy = ''
if (newborn.gender === 'girl') {
  toy = 'doll'
} else {
  toy = 'car'
}

giveToy(toy)
```

## Reducing control flows with ternary operators

Ternary operators let you create `if/else` statement in an easy-to-read manner. It has the following syntax:

```js
condition ? ifTruthy : ifFalsey
```

- The `condition` refers to the same condition in an `if/else` statement.
- `ifTruthy` refers to the statement to execute if the condition evaluates to true.
- `ifFalsey` refers to the statement to execute if the condition evalues to false.

The above `if/else` control flow would look like this with ternary operators:

```js
const toy = newborn === 'girl' ? 'doll' : car
giveToy(toy)
```

Much easier to read, isn't it?

### Don't go overboard with ternary operators

If you want to create nested `if/else` statements with ternary operators, make sure you don't nest more than one layer, or your code may become hard to read.

```js
const toy = newborn.gender === 'girl'
  ? newborn.birthMonth === 'December'
    ? 'candy cane'
    : 'doll'
  : newborn.birthMonth === 'December'
    ? 'santa hat'
    : 'car'
```

## Reducing control flows with early returns

If you want to gift the newborn a toy depending on the month of birth, you'd normally use an `if/else ` statement with lots of `else if` conditions.

```js
let toy = ''
if (newborn.birthMonth === 'January') {
  toy = 'candy cane'
} else if (newborn.birthMonth === 'February') {
  toy = 'socks'
} else if (newborn.birthMonth === 'March') {
  toy = 'hat'
} else {
  toy = 'mittens'
}
```

Was it hard to make it through the series of `else if` statements? In this case, it's somewhat ease because we know the conditions follow a pattern. If the conditions don't follow a pattern, which is what normally happens, `else if` statements can make your code hard to read.

This is when you should use early returns.

An early return is a `return` statement in a function that terminates before the function is fully executed.

```js
const getToy = month => {
  if (newborn.birthMonth === 'January') return 'candy cane'
  if (newborn.birthMonth === 'February') return 'socks'
  if (newborn.birthMonth === 'March') return 'hat'
  return 'mittens'
}
```

## Avoid reassignments

Did you notice reassignments often happen in `if/else` or `if/else if/else` statements?

In most cases, you can avoid reassignments if you avoid control flows. Try to use `const` over `let` as much as you can. From this point on, whenever you declare a variable with `let`, look out for a way to refactor it into `const`.

AViod reassignments.

Whenever you declare a variable with `let`, you tell yourself that this variable is going to change later. You need to keep track of it somehow. When you do so, you send a tiny signal to the brain, asking it to branch off some code.

Create a tiny branch in case you need to get back to it.