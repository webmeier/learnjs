# ðŸ›  Building a carousel (part 3)

In this lesson, you'll learn to tidy up the carousel code. There'll be no changes to the carousel visually, but the code you write will reduce by about 70%.

Interested to find out how? Let's jump ahead.

You'll find the starter files for this lesson in `components/05.carousel/02.basic-part-2-completed`.

## Refactoring

The process of restructuring code is called refactoring.
When you refactor, you want the results to remain the same while you tidy your code up.

To refactor, you try create functions to reuse similar blocks of code; you also see if you can find better ways to write the code. It's hard to explain what is "better", but you'll learn about it through the refactoring process.

In this case, we can do both. Let's start by creating functions to reuse code.

## Grouping code into reusable functions

If you create a function to reuse a block of code, you can run a single function instead of duplicating repeated lines of code. This is a practice called Don't Repeat Yourself (DRY).

Developers often make the mistake of DRYing code before they need to. If you DRY your code prematurely, you'll have a hard time building your component because you'll wrestle with your "best practice" code.

To correctly DRY something, you wait for any of these to happen:

1. You use the same code multiple times (maybe three or more).
2. You've completed what you wanted to build (like what we've done).

### A function to get the current slide

If you look at the event handlers, you'll notice we used the following code three times:

```js
let currentSlide

for (let slide of slides) {
  if (slide.classList.contains('is-selected')) {
    currentSlide = slide
  }
}
```

This set of code, although understandable, takes up precious brain bandwidth. When we write code, we want to be able to glance through each of our functionsÂ (remember, a event listener contains a callback, which is also a function) and have an idea of what they do.

Since this code attempts to get the current slide, we can group it into a function called `getCurrentSlide`. Note how this function is named after an action it is supposed do.

To get the current slide, you need to return `currentSlide` after the `for` loop. You also want to pass in a `slides` variable, which contains an array of slides in the carousel, to `getCurrentSlide` so it doesn't depend on external variables.

Make sure to place this function above your event listeners. Remember that function expressions do not get hoisted, and you should never depend on hoisting in the first place.

```js
const getCurrentSlide = slides => {
  let currentSlide

  for (let slide of slides) {
    if (slide.classList.contains('is-selected')) {
      currentSlide = slide
    }
  }

  return currentSlide
}
```

```js
nextButton.addEventListener('click', e => {
  const currentSlide = getCurrentSlide(slides)
  // ...
})

previousButton.addEventListener('click', e => {
  const currentSlide = getCurrentSlide(slides)
  // ...
})

dotContainer.addEventListener('click', e => {
  if (!e.target.matches('button')) return

  const currentSlide = getCurrentSlide(slides)
  // ...
})
```

### A function to update slides

We have also written code to update slides (both visually and in the DOM) three times. The code differs slightly each time, but they have a general structure that follows this pattern:

```js
// Find amount to move and set track
const amountToMove = targetSlide.style.left
track.style.left = '-' + amountToMove

// Remove is-selected from current slide and add it to the target slide
currentSlide.classList.remove('is-selected')
targetSlide.classList.add('is-selected')
```

We can pull these four lines of code into a separate function called `updateSlides`. This function needs to know three thingsâ€”the track, the current slide, and the target slide.

```js
const updateSlides = (track, currentSlide, targetSlide) => {
  const amountToMove = targetSlide.style.left
  track.style.left = '-' + amountToMove
  currentSlide.classList.remove('is-selected')
  targetSlide.classList.add('is-selected')
}
```

We can further reduce it to three lines of code by removing the variable called `amountToMove`.

```js
const updateSlides = (track, currentSlide, targetSlide) => {
  track.style.left = '-' + targetSlide.style.left
  currentSlide.classList.remove('is-selected')
  targetSlide.classList.add('is-selected')
}
```

Then, we can update our event listeners to:

```js
nextButton.addEventListener('click', e => {
  // ...
  updateSlides(track, currentSlide, nextSlide)
})

previousButton.addEventListener('click', e => {
  // ...
  updateSlides(track, currentSlide, previousSlide)
})

dotContainer.addEventListener('click', e => {
  // ...
  updateSlides(track, currentSlide, targetSlide)
})
```

### A function to update dots

We've also repeated the code to update dots three times. It's slightly different each time, but there's a general structure:

```js
// Get current dot
const currentDot = dotContainer.querySelector('.is-selected')
// Gets the next Dot (this is different each time)
const nextDot = currentDot.nextElementSibling

// Updates the DOM
currentDot.classList.remove('is-selected')
nextDot.classList.add('is-selected')
```

Here, we can reuse the code that changes the `is-selected` class on both `currentDot` and `targetDot`. We can't reuse the code for `currentDot` because `targetDot` requires it to work in two of three cases.

```js
const updateDots = (currentDot, targetDot) => {
  currentDot.classList.remove('is-selected')
  targetDot.classList.add('is-selected')
}
```

We can update our event listeners to:

```js
nextButton.addEventListener('click', e => {
  // ...
  const dotContainer = document.querySelector('.jsDotContainer')
  const currentDot = dotContainer.querySelector('.is-selected')
  const nextDot = currentDot.nextElementSibling
  updateDots(currentDot, nextDot)
})

previousButton.addEventListener('click', e => {
  // ...
  const dotContainer = document.querySelector('.jsDotContainer')
  const currentDot = dotContainer.querySelector('.is-selected')
  const previousDot = currentDot.previousElementSibling
  updateDots(currentDot, previousDot)
})

dotContainer.addEventListener('click', e => {
  // ...
  const clickedDot = e.target
  const currentDot = dotContainer.querySelector('.is-selected')
  updateDots(currentDot, clickedDot)
})
```

Notice we had to get the `dotContainer` three times (twice within `nextButton`'s and `previousButton` event handers, and once to listen for clicks on the dots)? If we moved the code that selects `dotContainer` above all our event listeners, we can define it once, and our event listeners would all have access to `dotContainer`. (Why is this so?)

With that, we can change our event listeners to:

```js
const dotContainer = document.querySelector('.jsDotContainer')

nextButton.addEventListener('click', e => {
  // ...
  const currentDot = dotContainer.querySelector('.is-selected')
  const nextDot = currentDot.nextElementSibling
  updateDots(currentDot, nextDot)
})

previousButton.addEventListener('click', e => {
  // ...
  const currentDot = dotContainer.querySelector('.is-selected')
  const previousDot = currentDot.previousElementSibling
  updateDots(currentDot, previousDot)
})

dotContainer.addEventListener('click', e => {
  // ...
  const clickedDot = e.target
  const currentDot = dotContainer.querySelector('.is-selected')
  updateDots(currentDot, clickedDot)
})
```

## A function to update arrows

Each of our three event listener updates arrows in a different way.

```js
nextButton.addEventListener('click', e => {
  // ...
  const isFinalSlide = !nextSlide.nextElementSibling
  if (isFinalSlide) {
    nextButton.classList.add('is-hidden')
  }

  previousButton.classList.remove('is-hidden')
})
```

```js
previousButton.addEventListener('click', e => {
  // ...
  const isFirstSlide = !previousSlide.previousElementSibling
  if (isFirstSlide) {
    previousButton.classList.add('is-hidden')
  }

  nextButton.classList.remove('is-hidden')
})
```

```js
dotContainer.addEventListener('click', e => {
  // ...
  if (targetIndex === 0) {
    previousButton.classList.add('is-hidden')
    nextButton.classList.remove('is-hidden')
  } else if (targetIndex === slides.length - 1) {
    previousButton.classList.remove('is-hidden')
    nextButton.classList.add('is-hidden')
  } else {
    previousButton.classList.remove('is-hidden')
    nextButton.classList.remove('is-hidden')
  }
})
```

Of these three sets of code that updates the arrow buttons, the `dotContainer` event listener's code is the most robustâ€”it checks if we're on the first slide, if we're on the final slide, if we're between the first and final slides, and acts accordingly.

If we want to extract code into a separate function, we'll want the function to behave correctly in as many situations as possible, so the `dotContainer`'s code is preferred over `nextButton` and `previousButton`'s code.

Let's extract that into a function called `updateArrows`. Note that this function needs four variablesâ€”`targetIndex`, `previousButton`, `nextButton`, and `slides`â€”to work.

```js
const updateArrows = (targetIndex, previousButton, nextButton, slides) => {
  if (targetIndex === 0) {
    previousButton.classList.add('is-hidden')
    nextButton.classList.remove('is-hidden')
  } else if (targetIndex === slides.length - 1) {
    previousButton.classList.remove('is-hidden')
    nextButton.classList.add('is-hidden')
  } else {
    previousButton.classList.remove('is-hidden')
    nextButton.classList.remove('is-hidden')
  }
}
```

It's a bit of a chore to select `previousButton`, `nextButton`, and `slides` in every event listener.

If we assign the correct values to `previousButton`, `nextButton`, and `slides` before any of our event listeners, we don't need to pass `previousButton` and `nextButton` variables into the function:

```js
const slides = Array.from(track.children)
const nextButton = document.querySelector('.jsNext')
const previousButton = document.querySelector('.jsPrevious')
// ...

const updateArrows = targetIndex => {
  if (targetIndex === 0) {
    previousButton.classList.add('is-hidden')
    nextButton.classList.remove('is-hidden')
  } else if (targetIndex === slides.length - 1) {
    previousButton.classList.remove('is-hidden')
    nextButton.classList.add('is-hidden')
  } else {
    previousButton.classList.remove('is-hidden')
    nextButton.classList.remove('is-hidden')
  }
}
```

We can use `updateArrows` in `dotContainer`'s event listener directly since there's a `targetIndex` value.

```js
dotContainer.addEventListener('click', e => {
  // ...
  updateArrows(targetIndex)
})
```

### updateArrows in the previous button's and next button's event listener

To use `updateArrows` in previous button's and next button's event listener, you need to figure out what the `targetIndex` is.

To find the `targetIndex`, you need to know the index of `currentSlide`. You can do that through a for loop. Let's create a function called `getCurrentIndex` that does this:

```js
const getCurrentIndex = slides => {
  let currentIndex

  for (let index = 0; index < dots.length; index++) {
    const slide = slides[index]
    if (slide.classList.contains('is-selected')) {
      currentIndex = slide
    }
  }

  return currentIndex
}
```

Doesn't `getCurrentIndex` look awfully similar to `getCurrentSlide`? Since these two functions are similar, and both runs `for` loops, it makes sense for us to use only one of them in each event listener. In this case, let's choose to use `getCurrentIndex` since we can get `currentSlide` from `slides[currentIndex]`. (Why?).

```js
nextButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const currentSlide = slides[currentIndex]
  // ...
})

previousButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const currentSlide = slides[currentIndex]
  // ...
})
```

Once we know the `currentIndex`, getting the `targetIndex` for each event listener is straightforward. The `targetIndex` for the next button's event listener is `currentIndex + 1` while `targetIndex` of the previous button's event listener is `currentIndex - 1`. (Why?)

Once you know the targetIndex, you can use `updateArrows` in all three event listeners.

```js
nextButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const nextIndex = currentIndex + 1
  // ...
  updateArrows(nextIndex)
})

previousButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const previousIndex = currentIndex - 1
  // ...
  updateArrows(previousIndex)
})
```

Once we have `targetIndex`, we can use `targetIndex` to search for the previous and next slide too.

```js
nextButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const nextIndex = currentIndex + 1
  const currentSlide = slides[currentIndex]
  const nextSlide = slides[nextIndex]

  // ...
})

previousButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const previousIndex = currentIndex - 1
  const currentSlide = slides[currentIndex]
  const previousSlide = slides[previousIndex]

  // ...
})
```

At this point, did you notice we could also swap out `nextElementSibling`/`previousElementSibling` to find the next/previous dot?

Let's try that.

### Using indexes to find dots

If we had an array that contains the three dots, we could search for the next and previous dot. If we do that, our next and previous button event listeners look like this:

```js
const dots = Array.from(dotContainer.children)
// ...

nextButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const nextIndex = currentIndex + 1
  const currentSlide = slides[currentIndex]
  const nextSlide = slides[nextIndex]
  const currentDot = dots[currentIndex]
  const nextDot = dots[nextIndex]

  updateSlides(track, currentSlide, nextSlide)
  updateDots(currentDot, nextDot)
  updateArrows(nextIndex)
})

previousButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const previousIndex = currentIndex + 1
  const currentSlide = slides[currentIndex]
  const previousSlide = slides[previousIndex]
  const currentDot = dots[currentIndex]
  const previousDot = dots[previousIndex]

  updateSlides(track, currentSlide, previousSlide)
  updateDots(currentDot, previousDot)
  updateArrows(previousIndex)
})
```

## Reducing brain overload in each event listener

There are six variables in `previousButton`'s and `nextButton`'s event listeners right now. When you look at the code, don't your eyes just glaze over these variables? That's a sign of overload. Our brains cannot keep track of so many variables at once.

To reduce the number of variables in each event listener, we can refactor `updateSlides` so it uses `currentIndex` and `targetIndex`. This reduces the need for two variables.

```js
const updateSlides = (track, currentIndex, targetIndex) => {
  const currentSlide = slides[currentIndex]
  const targetSlide = slides[targetIndex]
  track.style.left = '-' + targetSlide.style.left
  currentSlide.classList.remove('is-selected')
  targetSlide.classList.add('is-selected')
}
```

Our event listener becomes this:

```js
nextButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const nextIndex = currentIndex + 1
  const currentDot = dots[currentIndex]
  const nextDot = dots[nextIndex]

  updateSlides(track, currentIndex, nextIndex)
  updateDots(currentDot, nextDot)
  updateArrows(nextIndex)
})
```

It became more manageable, don't you think?

Similarly, we can refactor `updateDots` to take in `currentIndex` and `targetIndex` instead of `currentDot` and `targetDot`. That'll reduce two more variables in our event listeners.

```js
const updateDots = (currentIndex, targetIndex) => {
  dots[currentIndex].classList.remove('is-selected')
  dots[targetIndex].classList.add('is-selected')
}
```

```js
nextButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const nextIndex = currentIndex + 1

  updateSlides(track, currentIndex, nextIndex)
  updateDots(currentIndex, nextIndex)
  updateArrows(nextIndex)
})
```

This is very manageable now. When you look at your event listener, you know immediately what it's supposed to do.

Let's do the same for `previousButton`'s event handler and the dots event handler.

### Tidying up previousButton's event handler

```js
previousButton.addEventListener('click', e => {
  const currentIndex = getCurrentIndex(slides)
  const previousIndex = currentIndex - 1

  updateSlides(track, currentIndex, previousIndex)
  updateDots(currentIndex, previousIndex)
  updateArrows(previousIndex)
})
```

### Refactoring dots event handler

```js
dotContainer.addEventListener('click', e => {
  if (!e.target.matches('button')) return

  const currentIndex = getCurrentIndex(slides)
  const clickedDot = e.target
  let targetIndex

  for (let index = 0; index < dots.length; index++) {
    if (dots[index] === clickedDot) {
      targetIndex = index
    }
  }

  updateSlides(track, currentIndex, targetIndex)
  updateDots(currentIndex, targetIndex)
  updateArrows(targetIndex)
})
```

## Naming callbacks for each event listener

We've been saying `nextButton`'s event listener, `previousButton`'s event listener, `dotContainer`'s event listener for a while. It's quite a mouthful, don't you think?

We know the `nextButton`'s eventlister is supposed to change to the next slide, the `previousButton`'s event listener is supposed to change to the previous slide, and the `dotContainer` event listener is supposed to change to the target slide.

Why don't we create functions for each event callback as well? We can call them `nextSlide`, `previousSlide` and `setSlide`.

```js
const nextSlide = e => {
  const currentIndex = getCurrentIndex(slides)
  const nextIndex = currentIndex + 1

  updateSlides(track, currentIndex, nextIndex)
  updateDots(currentIndex, nextIndex)
  updateArrows(nextIndex)
}

const previousSlide = e => {
  const currentIndex = getCurrentIndex(slides)
  const previousIndex = currentIndex - 1

  updateSlides(track, currentIndex, previousIndex)
  updateDots(currentIndex, previousIndex)
  updateArrows(previousIndex)
}

const setSlide = e => {
  if (!e.target.matches('button')) return

  const currentIndex = getCurrentIndex(slides)
  const clickedDot = e.target
  let targetIndex

  for (let index = 0; index < dots.length; index++) {
    if (dots[index] === clickedDot) {
      targetIndex = index
    }
  }

  updateSlides(track, currentIndex, targetIndex)
  updateDots(currentIndex, targetIndex)
  updateArrows(targetIndex)
}

nextButton.addEventListener('click', nextSlide)
previousButton.addEventListener('click', previousSlide)
dotContainer.addEventListener('click', setSlide)
```

## Cleaning unused code

`getCurrentSlide` is no longer used in the code at this point. It's safe to remove it.

## Reducing global variables

One JavaScript best practice is to reduce the number global variables you declare. In this set of code, we have created seven variablesâ€”`track`, `slides`, `nextButton`, `previousButton`, `dotContainer`, `dots`, and `slideWidth`.

Since none of these variables are needed in other components, its best we don't pollute the global scope by adding these variables. Who knows if we'll need a `dots` or `nextButton` variable in another component?

A simple way to prevent yourself from polluting the global scope is to enclose our code within a block scope:

```js
{
  // ... our code here
}
```

## Wrapping up

At the start of this lesson, you had 126 lines of JavaScript code. Although it worked, you probably felt yucky about the amount of duplication you've wrote.

After completing the refactor, you're left with 95 lines of code. That's 25% shorter than the original version. We've also created functions to reuse blocks of code to keep the program DRY.

Can we improve the code further? We can, but let's wait till we learn more best practices. We'll continue to refactor as you learn more.

Now for your homework, go through this refactoring exercise again on your own.