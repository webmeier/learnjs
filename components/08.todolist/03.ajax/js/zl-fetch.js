!(function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t(require("btoa")) : "function" == typeof define && define.amd ? define(["btoa"], t) : "object" == typeof exports ? exports.zlFetch = t(require("btoa")) : e.zlFetch = t(e._) }(window, function (e) { return function (e) { var t = {}; function n(r) { if (t[r]) return t[r].exports; var o = t[r] = { i: r, l: !1, exports: {} }; return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports } return n.m = e, n.c = t, n.d = function (e, t, r) { n.o(e, t) || Object.defineProperty(e, t, { configurable: !1, enumerable: !0, get: r }) }, n.r = function (e) { Object.defineProperty(e, "__esModule", { value: !0 }) }, n.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return n.d(t, "a", t), t }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 3) }([function (e, t) { const n = (e, t) => e[t]().then(t => s(e, t)), r = e => { const t = {}; for (let [n, r] of e.headers.entries()) t[n] = r; return t }, o = e => { const t = {}, n = e.headers._headers; for (const e in n) t[e] = n[e].join(""); return t }, s = (e, t) => { const n = { body: t, headers: (e => e.headers.entries ? r(e) : o(e))(e), response: e, status: e.status, statusText: e.statusText }; return e.ok ? Promise.resolve(n) : Promise.reject(n) }; e.exports = (e => { const t = e.headers.get("content-type"); if (t.includes("json")) return n(e, "json"); if (t.includes("text")) return n(e, "text"); if (t.includes("image")) return n(e, "blob"); throw new Error(`zlFetch does not support content-type ${t} yet`) }) }, function (t, n) { t.exports = e }, function (e, t, n) { const r = e => { if (e) return Object.entries(e).reduce((e, t, n) => { const [r, o] = t; return `${e}${0 === n ? `${r}=${encodeURIComponent(o)}` : `&${r}=${encodeURIComponent(o)}`}` }, "") }; e.exports = ((e = {}) => { const t = Object.assign({}, e); return t.url = (e => { const { url: t, params: n } = e; return n ? `${t}?${r(n)}` : t })(t), t.method = t.method || "get", t.headers = (({ headers: e = {}, body: t, method: r, username: o, password: s, token: u } = {}) => { const c = new Headers(e); if (o || s) { if (!o) throw new TypeError("username required for basic authentication"); if (!s) throw new TypeError("password required for basic authentication"); const e = "function" == typeof btoa ? btoa : n(1); c.set("Authorization", `Basic ${e(`${o}:${s}`)}`) } return u && c.set("Authorization", `Bearer ${u}`), c.get("content-type") || c.set("content-type", "application/json"), c })(t), t.body = (e => { const t = e.headers.get("content-type"); return t.includes("json") ? JSON.stringify(e.body) : t.includes("x-www-form-urlencoded") ? r(e.body) : e.body })(t), delete t.username, delete t.password, delete t.token, t }) }, function (e, t, n) { const r = n(2), o = n(0), s = (e, t) => { const n = r(Object.assign({ url: e }, t)); return fetch(n.url, n).then(o) }; e.exports = s, e.exports.default = s }]) }));
